namespace AB

types
    ABProgram;
    Integer, String     <: Type;
    Decl;
    ClearStmt, ConverseStmt, HandlerStmt, IfStmt, MapStmt, OverlayStmt, PrintStmt, ReturnStmt
                        <: Stmt;
    Var, Lit            <: Expr;

tokens
  ' ', '\r', '\n' :: skip
  ';', '(', ')' :: mark
  'dcl', 'enddcl', 'integer', 'char',
  'clear', 'converse', 'handler', 'if', 'endif', 'map', 'to', 'overlay', 'print', 'return' :: word
  number :: Num
  string :: Id % split by?

handlers
    EOF                 -> push ABProgram(data,code)
                           where code := pop# Stmt,
                                 data := pop# Decl
    Num                 -> push Lit(this)
    Id                  -> push Var(this)

    'dcl'               -> lift DCL
    'enddcl'            -> drop DCL
    ';' given DCL       -> push Decl(v,t)
                           where t := pop Type,
                                 v := pop Var
    'integer' given DCL -> push Integer
    'char'    given DCL -> push String(n)
                           where x := await (Lit given BRACKET) with CHAR,
                                 n := tear x
    '(' given CHAR      -> lift BRACKET
    '(' given HANDLER   -> lift BRACKET
    ')'                 -> drop BRACKET

    'clear'             -> push ClearStmt(view)
                           where view := await Var
    'converse'          -> push ConverseStmt(win)
                           where win := await Var with CONVERSE
    % ----------------- begin DO ------------------------------------------------------------------------
    %'do'                -> push DoStmt(doFrom,doTo,doBy,doIndex,block1,doWhile,block2)
    %                       where ...
    %'from' given DO     -> next Expr push 
    % -----------------  end  DO ------------------------------------------------------------------------
    'handler'           -> push HandlerStmt(obj,proc)
                           where obj  := await Var,
                                 proc := await (Var given BRACKET) with HANDLER
    'if'                -> push IfStmt(cond,branch)
                           where cond   := await Expr with IF,
                                 branch := await* Stmt
    'endif'             -> trim Stmt*
    'map'               -> push MapStmt(source,target)
                           where source := await Expr with MAP,
                                 target := await Var with MAP
    'overlay'           -> push OverlayStmt(source,target)
                           where source := await Expr with MAP,
                                 target := await Var with MAP
    'print'             -> push PrintStmt(message)
                           where message := await Expr
    'return'            -> push ReturnStmt

%    V given MAP         -> assert exists Decl(v,t) such that v == this
